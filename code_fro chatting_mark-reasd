  path('rooms/<str:room_id>/mark-read/', views.MarkMessagesReadView.as_view(), name='mark_messages_read'),
    path('rooms/<str:room_id>/mark-all-read/', views.MarkAllMessagesReadView.as_view(), name='mark_all_messages_read'),




# ---------------------------------------------
# ChatConsumer
# ---------------------------------------------
class ChatConsumer(BaseJsonConsumer):
    """
    WebSocket consumer for handling chat messages between users
    Supports rep-solo and company-solo conversations with company oversight
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # typing state for THIS connection/user
        self._typing_task = None
        self._typing_active = False

    async def connect(self):
        try:
            self.room_id = self.scope["url_route"]["kwargs"]["room_id"]
            self.room_group_name = f"chat_{self.room_id}"
            self.user = self.scope.get("user")

            if not self.user or self.user.is_anonymous:
                await self.close(code=4001)
                return

            can_join = await self.can_user_join_room()
            if not can_join:
                await self.close(code=4003)
                return

            await self.channel_layer.group_add(self.room_group_name, self.channel_name)
            await self.accept()
            await self.update_user_online_status(True)

            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    "type": "user_joined",
                    "user_id": self.user.id,
                    "user_name": self.user.full_name,
                    "timestamp": timezone.now().isoformat(),
                },
            )
            logger.info(f"User {self.user.id} connected to chat room {self.room_id}")

        except Exception as e:
            logger.error(f"Error in chat connect: {str(e)}")
            await self.close(code=4000)

    async def disconnect(self, close_code):
        try:
            await self.update_user_online_status(False)
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    "type": "user_left",
                    "user_id": self.user.id,
                    "user_name": self.user.full_name,
                    "timestamp": datetime.now(),
                },
            )
            await self.channel_layer.group_discard(self.room_group_name, self.channel_name)
            logger.info(f"User {self.user.id} disconnected from chat room {self.room_id}")
        except Exception as e:
            logger.error(f"Error in chat disconnect: {str(e)}")

    async def receive(self, text_data):
        try:
            logger.debug(f"Received data: {text_data}")
            data = json.loads(text_data)
            message_type = data.get("type", "chat_message")

            if message_type == "chat_message":
                await self.handle_chat_message(data)
            elif message_type == "typing":
                await self.handle_typing_indicator(data)
            elif message_type == "mark_read":
                await self.handle_mark_read(data)
            else:
                logger.warning(f"Unknown message type: {message_type}")

        except json.JSONDecodeError:
            await self.send_json({"type": "error", "message": "Invalid message format"})
        except Exception as e:
            logger.error(f"Error in receive: {str(e)}")
            await self.send_json({"type": "error", "message": "Server error"})

    async def handle_chat_message(self, data):
        try:
            content = data.get("message", "").strip()
            message_type = data.get("message_type", "text")
            file_data = data.get("file_data", {})
            reply_to_id = data.get("reply_to")

            # Content validation - text messages need content, but file/image messages don't require it
            if message_type == "text" and not content:
                await self.send_json({"type": "error", "message": "Text messages cannot be empty"})
                return

            # File data validation for media messages
            if message_type in ["image", "document", "file"] and not file_data.get("file_url"):
                await self.send_json({"type": "error", "message": f"{message_type.title()} messages require file data"})
                return

            can_send = await self.can_user_send_message()
            if not can_send:
                await self.send_json({"type": "error", "message": "You do not have permission to send messages"})
                return

            reply_to_message = None
            if reply_to_id:
                reply_to_message = await self.get_reply_message(reply_to_id)
                if not reply_to_message:
                    pass

            # Process and save the message
            message = await self.save_message(
                content=content,
                message_type=message_type,
                file_data=file_data,
                reply_to=reply_to_message,
            )

            # Broadcast only identifiers; each recipient will serialize the message
            await self.channel_layer.group_send(
                self.room_group_name,
                {"type": "chat_message", "room_id": self.room_id, "message_id": message.id},
            )

            # Acknowledge successful message submission to the sender
            await self.send_json({
                "type": "message_sent", 
                "message_id": message.id,
                "success": True
            })

        except Exception as e:
            logger.error(f"Error handling chat message: {str(e)}")
            await self.send_json({"type": "error", "message": "Failed to send message"})


    async def handle_typing_indicator(self, data):
        """
        Debounced/TTL typing indicator:
        - start: broadcast immediately, then schedule auto-stop after short idle window
        - subsequent keypresses: just reset the timer (no spam)
        - stop: broadcast immediately and cancel timer
        """
        try:
            is_typing = bool(data.get("is_typing", False))
            ttl_seconds = float(data.get("ttl", 1.2))  # allow client to override, default ~1.2s

            if is_typing:
                # Broadcast START only if not already active
                if not self._typing_active:
                    self._typing_active = True
                    await self.channel_layer.group_send(
                        self.room_group_name,
                        {
                            "type": "typing_indicator",
                            "user_id": self.user.id,
                            "user_name": self.user.full_name,
                            "is_typing": True,
                            "timestamp": timezone.now().isoformat(),
                        },
                    )
                # Reset the idle timeout
                if self._typing_task and not self._typing_task.done():
                    self._typing_task.cancel()
                self._typing_task = asyncio.create_task(self._typing_timeout(ttl_seconds))

            else:
                # Explicit STOP from client: cancel timer and broadcast stop if active
                await self._typing_stop_broadcast()

        except Exception as e:
            logger.error(f"Error handling typing indicator: {str(e)}")

    async def _typing_timeout(self, delay: float):
        try:
            await asyncio.sleep(delay)
            await self._typing_stop_broadcast()
        except asyncio.CancelledError:
            # Keystroke arrived in time; just exit
            pass

    async def _typing_stop_broadcast(self):
        """Cancel timer and broadcast stop if we are currently active."""
        if self._typing_task and not self._typing_task.done():
            self._typing_task.cancel()
        if self._typing_active:
            self._typing_active = False
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    "type": "typing_indicator",
                    "user_id": self.user.id,
                    "user_name": self.user.full_name,
                    "is_typing": False,
                    "timestamp": timezone.now().isoformat(),
                },
            )

    async def typing_indicator(self, event):
        if event["user_id"] != self.user.id:
            # normalize payload (explicit type & ISO timestamp already set above)
            event["type"] = "typing"
            await self.send_json(event)

    async def handle_mark_read(self, data):
        try:
            message_id = data.get("message_id")
            message_ids = data.get("message_ids", [])
            
            # Support both single message and bulk marking
            if message_id:
                message_ids = [message_id]
            
            if not message_ids:
                await self.send_json({"type": "error", "message": "No message IDs provided for mark read"})
                return
            
            # Mark messages as read
            marked_messages = await self.mark_messages_read(message_ids)
            
            if marked_messages:
                # Broadcast read status update to all room participants
                await self.channel_layer.group_send(
                    self.room_group_name,
                    {
                        "type": "message_read_update",
                        "room_id": self.room_id,
                        "message_ids": marked_messages,
                        "user_id": self.user.id,
                        "user_name": self.user.full_name,
                        "timestamp": timezone.now().isoformat(),
                    }
                )
                
                # Send chat list updates to all participants (unread count changed)
                await self._send_chat_list_updates_for_read_status()
                
                # Acknowledge to sender
                await self.send_json({
                    "type": "messages_marked_read",
                    "message_ids": marked_messages,
                    "success": True
                })
            
        except Exception as e:
            logger.error(f"Error marking message as read: {str(e)}")
            await self.send_json({"type": "error", "message": "Failed to mark message as read"})

    # Outgoing events (all use safe encoder)

    async def chat_message(self, event):
        """
        Normalize to the SAME shape as API messages_data[] for this viewer.
        Accepts both:
        1) {"message_id": 123}
        2) {"message": {"id": 123, ...}}   # legacy producers
        """
        # --- Accept both new and legacy event shapes ---
        message_id = event.get("message_id")
        if not message_id:
            legacy_msg = event.get("message")
            if isinstance(legacy_msg, dict):
                message_id = legacy_msg.get("id")

        if not message_id:
            logger.error("WS chat_message event missing message_id (and legacy message.id). Ignoring.")
            return

        # --- Serialize to API shape for this viewer ---
        try:
            msg_obj = await self._serialize_message_for_client(message_id, self.user)
        except Exception as e:
            logger.exception(f"Failed to serialize message {message_id}: {e}")
            return

        # Add a routing type; rest matches API exactly
        msg_obj["type"] = "chat_message"
        await self.send_json(msg_obj)


    async def typing_indicator(self, event):
        if event["user_id"] != self.user.id:
            await self.send_json(event)

    async def user_joined(self, event):
        if event["user_id"] != self.user.id:
            await self.send_json(event)

    async def user_left(self, event):
        if event["user_id"] != self.user.id:
            await self.send_json(event)

    async def message_read_update(self, event):
        """Handle read status updates from other users"""
        if event["user_id"] != self.user.id:
            await self.send_json({
                "type": "message_read_update",
                "room_id": event["room_id"],
                "message_ids": event["message_ids"],
                "user_id": event["user_id"],
                "user_name": event["user_name"],
                "timestamp": event["timestamp"]
            })

    async def chat_list_update(self, event):
        # 🔑 FIX: Use safe encoder here
        await self.send_json(event)

    # Wrapper for safe JSON sending
    async def send_json(self, data):
        await self.send(text_data=json.dumps(data, cls=DateTimeEncoder))

    # DB operations
    @database_sync_to_async
    def can_user_join_room(self):
        ChatRoom = apps.get_model("chat", "ChatRoom")
        try:
            chat_room = ChatRoom.objects.get(room_id=self.room_id)
            return chat_room.can_user_participate(self.user)
        except ChatRoom.DoesNotExist:
            return False

    @database_sync_to_async
    def can_user_send_message(self):
        ChatRoom = apps.get_model("chat", "ChatRoom")
        ChatParticipant = apps.get_model("chat", "ChatParticipant")
        try:
            chat_room = ChatRoom.objects.get(room_id=self.room_id)
            participant = ChatParticipant.objects.filter(chat_room=chat_room, user=self.user).first()
            return participant.can_send_messages if participant else chat_room.can_user_participate(self.user)
        except ChatRoom.DoesNotExist:
            return False

    @database_sync_to_async
    def save_message(self, content, message_type="text", file_data=None, reply_to=None):
        import base64
        import io
        import uuid
        from django.core.files.base import ContentFile
        from utils.storage_backends import upload_file_to_s3
        
        ChatRoom = apps.get_model("chat", "ChatRoom")
        Message = apps.get_model("chat", "Message")
        chat_room = ChatRoom.objects.get(room_id=self.room_id)

        message_data = {
            "chat_room": chat_room,
            "sender": self.user,
            "content": content,
            "message_type": message_type,
            "reply_to": reply_to,
        }

        if file_data:
            # Handle base64 encoded file data (direct WebSocket upload)
            if file_data.get("base64_data"):
                try:
                    # Decode base64 data
                    file_content = base64.b64decode(file_data.get("base64_data").split(',')[1] 
                                                   if ',' in file_data.get("base64_data") 
                                                   else file_data.get("base64_data"))
                    
                    # Create a Django file from the decoded data
                    file_name = file_data.get("file_name", f"{uuid.uuid4()}")
                    file = ContentFile(file_content, name=file_name)
                    
                    # Store the file directly in the attachment field (like user.image)
                    message_data.update({
                        "attachment": file,
                        "file_name": file_name,
                        "file_size": len(file_content),
                        "file_type": file_data.get("file_type", "application/octet-stream"),
                    })
                    
                    # Handle additional metadata if provided
                    if file_data.get("duration"):
                        message_data["duration"] = file_data.get("duration")
                    if file_data.get("dimensions"):
                        message_data["dimensions"] = file_data.get("dimensions")
                    if file_data.get("thumbnail_url"):
                        message_data["thumbnail_url"] = file_data.get("thumbnail_url")
                        
                except Exception as e:
                    logger.error(f"Error processing base64 file: {str(e)}")
                    # Continue with text message if file processing fails
                    pass

        return Message.objects.create(**message_data)

    @database_sync_to_async
    def get_reply_message(self, message_id):
        Message = apps.get_model("chat", "Message")
        ChatRoom = apps.get_model("chat", "ChatRoom")
        try:
            chat_room = ChatRoom.objects.get(room_id=self.room_id)
            return Message.objects.get(id=message_id, chat_room=chat_room)
        except Message.DoesNotExist:
            return None

    @database_sync_to_async
    def mark_message_read(self, message_id):
        Message = apps.get_model("chat", "Message")
        MessageReadStatus = apps.get_model("chat", "MessageReadStatus")
        try:
            message = Message.objects.get(id=message_id)
            read_status, _ = MessageReadStatus.objects.get_or_create(message=message, user=self.user)
            return read_status
        except Message.DoesNotExist:
            return None

    @database_sync_to_async
    def mark_messages_read(self, message_ids):
        """Mark multiple messages as read and return successfully marked message IDs"""
        Message = apps.get_model("chat", "Message")
        MessageReadStatus = apps.get_model("chat", "MessageReadStatus")
        ChatRoom = apps.get_model("chat", "ChatRoom")
        
        try:
            chat_room = ChatRoom.objects.get(room_id=self.room_id)
            
            # Get messages that exist in this room and aren't sent by current user
            messages = Message.objects.filter(
                id__in=message_ids,
                chat_room=chat_room
            ).exclude(sender=self.user)
            
            # Get existing read statuses to avoid duplicates
            existing_reads = set(
                MessageReadStatus.objects.filter(
                    message__in=messages,
                    user=self.user
                ).values_list("message_id", flat=True)
            )
            
            # Create new read statuses for unread messages
            new_reads = []
            marked_message_ids = []
            
            for message in messages:
                if message.id not in existing_reads:
                    new_reads.append(MessageReadStatus(message=message, user=self.user))
                    marked_message_ids.append(message.id)
                else:
                    # Already read, but include in response for consistency
                    marked_message_ids.append(message.id)
            
            if new_reads:
                MessageReadStatus.objects.bulk_create(new_reads)
            
            return marked_message_ids
            
        except ChatRoom.DoesNotExist:
            logger.error(f"ChatRoom {self.room_id} not found when marking messages as read")
            return []
        except Exception as e:
            logger.error(f"Error in mark_messages_read: {str(e)}")
            return []

    @database_sync_to_async
    def update_user_online_status(self, is_online):
        ChatRoom = apps.get_model("chat", "ChatRoom")
        ChatParticipant = apps.get_model("chat", "ChatParticipant")
        try:
            chat_room = ChatRoom.objects.get(room_id=self.room_id)
            participant, created = ChatParticipant.objects.get_or_create(
                chat_room=chat_room,
                user=self.user,
                defaults={"is_online": is_online},
            )
            if not created:
                participant.is_online = is_online
                participant.save(update_fields=["is_online", "last_seen_at"])
        except ChatRoom.DoesNotExist:
            pass

    async def _send_chat_list_updates_for_read_status(self):
        """Send chat list updates to all participants when read status changes"""
        try:
            ChatRoom = apps.get_model("chat", "ChatRoom")
            chat_room = await database_sync_to_async(ChatRoom.objects.get)(room_id=self.room_id)
            participants = await database_sync_to_async(list)(chat_room.get_participants())
            
            # Create a proper mock request class
            class MockRequest:
                def __init__(self, user):
                    self.user = user
                    self.META = {'HTTP_HOST': 'thereferralpro.com', 'wsgi.url_scheme': 'https'}

                def build_absolute_uri(self, location=None):
                    base = "https://thereferralpro.com"
                    return f"{base}{location}" if location else base
            
            for participant in participants:
                # Get updated chat room data with new unread counts
                rooms_data = await self._fetch_and_serialize_single_room(chat_room, participant)
                
                # Send to user's chat list group
                await self.channel_layer.group_send(
                    f"chat_list_{participant.id}",
                    {
                        "type": "chat_list_update",
                        "chat_rooms": [rooms_data],
                        "timestamp": timezone.now().isoformat()
                    }
                )
                
        except Exception as e:
            logger.error(f"Error sending chat list updates for read status: {str(e)}")

    @database_sync_to_async
    def _fetch_and_serialize_single_room(self, chat_room, viewer):
        """Serialize a single chat room for a specific viewer"""
        from utils.storage_backends import generate_presigned_url
        
        chat_image = chat_room.get_chat_image(viewer)
        image_url = generate_presigned_url(f"media/{chat_image}", expires_in=3600) if chat_image else None

        return {
            "room_id": chat_room.room_id,
            "room_type": chat_room.room_type,
            "chat_name": chat_room.get_display_name(viewer),
            "last_message": chat_room.get_last_message_summary(),
            "unread_count": chat_room.get_unread_count(viewer),
            "is_online": chat_room.is_any_participant_online(exclude_user=viewer),
            "is_active": chat_room.is_active,
            "created_at": chat_room.created_at.isoformat(),
            "updated_at": chat_room.updated_at.isoformat(),
            "referral_id": chat_room.referral.reference_id if getattr(chat_room, "referral", None) else None,
            "image_url": image_url,
        }

    @database_sync_to_async
    def _serialize_message_for_client(self, message_id, viewer):
        Message = apps.get_model("chat", "Message")
        msg = (
            Message.objects
            .select_related("sender", "chat_room")
            .prefetch_related("read_statuses")
            .get(id=message_id)
        )

        sender_image_url = (
            generate_presigned_url(f"media/{msg.sender.image}", expires_in=3600)
            if getattr(msg.sender, "image", None) else None
        )

        # Create base message data
        message_data = {
            "id": msg.id,
            "room_id": msg.chat_room.room_id,
            "sender": {
                "id": msg.sender.id,
                "name": msg.sender.full_name,
                "role": msg.sender.role,
                "image_url": sender_image_url,
            },
            "content": msg.content,
            "message_type": msg.message_type,
            "created_at": msg.created_at.isoformat(),
            "is_read": msg.read_statuses.filter(user=viewer).exists(),
            "read_by": list(msg.read_statuses.values_list("user_id", flat=True)),
        }
        
        # Add file-related fields for media messages
        if msg.message_type in ['image', 'video', 'audio', 'document', 'file']:
            message_data.update({
                "file_url": msg.get_file_url(),  # Use the method to get presigned URL
                "file_name": msg.file_name,
                "file_size": msg.file_size,
                "file_size_formatted": msg.file_size_formatted if hasattr(msg, 'file_size_formatted') else None,
                "file_type": msg.file_type,
                "duration": msg.duration,
                "thumbnail_url": msg.thumbnail_url,
                "dimensions": msg.dimensions,
                "attachments": msg.get_attachments_data(),  # Include all attachments
            })
            
        # Add reply info if this is a reply message
        if msg.reply_to:
            message_data["reply_to"] = {
                "id": msg.reply_to.id,
                "content": msg.reply_to.content[:100] + ('...' if len(msg.reply_to.content) > 100 else ''),
                "sender_name": msg.reply_to.sender.full_name,
                "message_type": msg.reply_to.message_type,
            }
            
        return message_data








class MarkMessagesReadView(APIView):
    """
    Mark one or multiple messages as read
    """
    permission_classes = [IsAuthenticated]
    
    def post(self, request, room_id):
        """Mark messages as read in a chat room"""
        try:
            chat_room = ChatRoom.objects.get(room_id=room_id)
            
            # Check if user can participate in this room
            if not chat_room.can_user_participate(request.user):
                return Response({
                    'success': False,
                    'error': 'You do not have access to this chat room'
                }, status=status.HTTP_403_FORBIDDEN)
            
            # Get message IDs from request
            message_id = request.data.get('message_id')
            message_ids = request.data.get('message_ids', [])
            
            # Support both single message and bulk marking
            if message_id:
                message_ids = [message_id]
            
            if not message_ids:
                return Response({
                    'success': False,
                    'error': 'No message IDs provided'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Get messages that exist in this room and aren't sent by current user
            messages = Message.objects.filter(
                id__in=message_ids,
                chat_room=chat_room
            ).exclude(sender=request.user)
            
            # Get existing read statuses to avoid duplicates
            existing_reads = set(
                MessageReadStatus.objects.filter(
                    message__in=messages,
                    user=request.user
                ).values_list("message_id", flat=True)
            )
            
            # Create new read statuses for unread messages
            new_reads = []
            marked_message_ids = []
            
            for message in messages:
                if message.id not in existing_reads:
                    new_reads.append(MessageReadStatus(message=message, user=request.user))
                    marked_message_ids.append(message.id)
                else:
                    # Already read, but include in response for consistency
                    marked_message_ids.append(message.id)
            
            if new_reads:
                MessageReadStatus.objects.bulk_create(new_reads)
            
            # Send real-time updates if any messages were newly marked as read
            if new_reads:
                self._send_read_status_updates(chat_room, marked_message_ids, request.user)
            
            return Response({
                'success': True,
                'message': f'Marked {len(marked_message_ids)} messages as read',
                'marked_message_ids': marked_message_ids
            }, status=status.HTTP_200_OK)
            
        except ChatRoom.DoesNotExist:
            return Response({
                'success': False,
                'error': 'Chat room not found'
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({
                'success': False,
                'error': f'Failed to mark messages as read: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def _send_read_status_updates(self, chat_room, message_ids, user):
        """Send real-time read status updates to WebSocket consumers"""
        try:
            from asgiref.sync import async_to_sync
            from channels.layers import get_channel_layer
            
            channel_layer = get_channel_layer()
            if not channel_layer:
                return
            
            # Send read status update to chat room
            async_to_sync(channel_layer.group_send)(
                f"chat_{chat_room.room_id}",
                {
                    "type": "message_read_update",
                    "room_id": chat_room.room_id,
                    "message_ids": message_ids,
                    "user_id": user.id,
                    "user_name": user.full_name,
                    "timestamp": timezone.now().isoformat(),
                }
            )
            
            # Send chat list updates to all participants (unread count changed)
            participants = chat_room.get_participants()
            for participant in participants:
                # Get updated chat room data for this specific user
                user_chat_rooms = self._get_user_chat_rooms_for_read_update(participant)
                
                # Create a proper mock request class
                class MockRequest:
                    def __init__(self, user):
                        self.user = user
                        self.META = {'HTTP_HOST': 'thereferralpro.com', 'wsgi.url_scheme': 'https'}

                    def build_absolute_uri(self, location=None):
                        base = "https://thereferralpro.com"
                        return f"{base}{location}" if location else base

                # Serialize the updated chat room list
                mock_request = MockRequest(participant)
                serialized = ChatRoomListSerializer(
                    [chat_room], many=True, context={'request': mock_request}
                ).data
                payload = json.loads(json.dumps(serialized, cls=DjangoJSONEncoder))

                async_to_sync(channel_layer.group_send)(
                    f"chat_list_{participant.id}",
                    {"type": "chat_list_update", "chat_rooms": payload}
                )
            
        except Exception as e:
            print(f"Error sending read status updates: {str(e)}")
    
    def _get_user_chat_rooms_for_read_update(self, user):
        """Get chat rooms for a specific user based on their role"""
        if user.role == 'solo':
            chat_rooms = ChatRoom.objects.filter(solo_user=user)
        elif user.role == 'employee':
            chat_rooms = ChatRoom.objects.filter(rep_user=user)
        elif user.role == 'company':
            chat_rooms = ChatRoom.objects.filter(
                Q(company_user=user) | 
                Q(rep_user__parent_company=user)
            )
        else:
            chat_rooms = ChatRoom.objects.none()
        
        # Add unread message count and last message info
        chat_rooms = chat_rooms.annotate(
            unread_count=Count(
                'messages', 
                filter=~Q(messages__read_statuses__user=user)
            )
        ).select_related(
            'solo_user', 'rep_user', 'company_user', 'referral'
        ).prefetch_related(
            'messages'
        ).order_by('-last_message_at')
        
        return chat_rooms


class MarkAllMessagesReadView(APIView):
    """
    Mark all messages in a chat room as read
    """
    permission_classes = [IsAuthenticated]
    
    def post(self, request, room_id):
        """Mark all unread messages in a chat room as read"""
        try:
            chat_room = ChatRoom.objects.get(room_id=room_id)
            
            # Check if user can participate in this room
            if not chat_room.can_user_participate(request.user):
                return Response({
                    'success': False,
                    'error': 'You do not have access to this chat room'
                }, status=status.HTTP_403_FORBIDDEN)
            
            # Get all unread messages in this room (excluding user's own messages)
            unread_messages = Message.objects.filter(
                chat_room=chat_room
            ).exclude(
                sender=request.user
            ).exclude(
                read_statuses__user=request.user
            )
            
            if not unread_messages.exists():
                return Response({
                    'success': True,
                    'message': 'No unread messages to mark',
                    'marked_count': 0
                }, status=status.HTTP_200_OK)
            
            # Create read statuses for all unread messages
            new_reads = [
                MessageReadStatus(message=msg, user=request.user)
                for msg in unread_messages
            ]
            
            MessageReadStatus.objects.bulk_create(new_reads)
            marked_message_ids = [msg.id for msg in unread_messages]
            
            # Send real-time updates
            self._send_read_status_updates_for_all_messages(chat_room, marked_message_ids, request.user)
            
            return Response({
                'success': True,
                'message': f'Marked {len(marked_message_ids)} messages as read',
                'marked_count': len(marked_message_ids),
                'marked_message_ids': marked_message_ids
            }, status=status.HTTP_200_OK)
            
        except ChatRoom.DoesNotExist:
            return Response({
                'success': False,
                'error': 'Chat room not found'
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({
                'success': False,
                'error': f'Failed to mark all messages as read: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def _send_read_status_updates_for_all_messages(self, chat_room, message_ids, user):
        """Send real-time read status updates when all messages are marked as read"""
        try:
            from asgiref.sync import async_to_sync
            from channels.layers import get_channel_layer
            
            channel_layer = get_channel_layer()
            if not channel_layer:
                return
            
            # Send read status update to chat room
            async_to_sync(channel_layer.group_send)(
                f"chat_{chat_room.room_id}",
                {
                    "type": "message_read_update",
                    "room_id": chat_room.room_id,
                    "message_ids": message_ids,
                    "user_id": user.id,
                    "user_name": user.full_name,
                    "timestamp": timezone.now().isoformat(),
                    "mark_all": True  # Flag to indicate this was a "mark all" operation
                }
            )
            
            # Send chat list updates to all participants (unread count changed to 0 for this user)
            participants = chat_room.get_participants()
            for participant in participants:
                # Create a proper mock request class
                class MockRequest:
                    def __init__(self, user):
                        self.user = user
                        self.META = {'HTTP_HOST': 'thereferralpro.com', 'wsgi.url_scheme': 'https'}

                    def build_absolute_uri(self, location=None):
                        base = "https://thereferralpro.com"
                        return f"{base}{location}" if location else base

                # Serialize the updated chat room list
                mock_request = MockRequest(participant)
                serialized = ChatRoomListSerializer(
                    [chat_room], many=True, context={'request': mock_request}
                ).data
                payload = json.loads(json.dumps(serialized, cls=DjangoJSONEncoder))

                async_to_sync(channel_layer.group_send)(
                    f"chat_list_{participant.id}",
                    {"type": "chat_list_update", "chat_rooms": payload}
                )
            
        except Exception as e:
            print(f"Error sending read status updates for all messages: {str(e)}")

